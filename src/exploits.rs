use std::io::Read;
use std::{
    io,
    process::{Command, Stdio},
    sync::{mpsc, Arc},
    thread::{sleep, spawn},
    time::{Duration, Instant},
};

use crate::{config::Config, stats::BambiStats, submit};

/// Start the exploit script for every addresses in the config.
pub fn run(command: Vec<String>, config: Config, stats: Arc<BambiStats>) {
    let command = Arc::new(command);
    let config = Arc::new(config);

    let time_diff = config.interval / config.addresses.len();
    let (sender, receiver) = mpsc::channel();
    let config_clone = config.clone();
    let gather_thread = spawn(move || submit::submit_thread(receiver, config_clone, stats));
    for address in &config.addresses {
        let address_clone = address.clone();
        let config_clone = config.clone();
        let command_clone = command.clone();
        let sender_clone = sender.clone();
        spawn(move || attack_thread(address_clone, command_clone, sender_clone, config_clone));
        sleep(Duration::from_secs(time_diff as _));
    }
    gather_thread.join().unwrap();
}

/// Start the exploit script for a given address.
fn attack_thread(
    address: String,
    command: Arc<Vec<String>>,
    sender: mpsc::Sender<Vec<u8>>,
    config: Arc<Config>,
) {
    loop {
        // TODO move sleep here, calculate appropriate diff
        let _ = start_team_exploit(&address, &command, &sender, &config);
    }
}

fn start_team_exploit(
    address: &str,
    command: &[String],
    sender: &mpsc::Sender<Vec<u8>>,
    config: &Config,
) -> io::Result<()> {
    // println!("start_team_exploit {:?} | {}", &command, address);
    let start_time = Instant::now();
    let mut command = command.to_owned();
    command.push(address.to_owned());
    let mut child = Command::new(&command[0])
        .args(&command[1..])
        .stdout(Stdio::piped())
        .stderr(Stdio::null())
        .spawn()?;

    // Wait for child. Post-natal abortion if required.
    loop {
        sleep(Duration::from_secs(1));

        // Is child dead?
        match child.try_wait() {
            // Yes
            Ok(Some(_exit_code)) => break,
            // No
            Ok(None) => {}
            // Maybe -- Let's kill it again just to make sure
            Err(e) => {
                let _ = child.kill();
                return Err(e);
            } // WTF is going on
        }

        // Ensure child is dead if it takes too long
        if Duration::from_secs(config.interval as _) < Instant::now() - start_time {
            let _ = child.kill();
            break;
        }
    }

    // Harvest organs ääh stdout
    let mut output = child.stdout.unwrap();
    let mut buf = vec![];
    output.read_to_end(&mut buf)?;

    for flag_match in config.flag_re.find_iter(&buf) {
        // Send only fails if the other end is already closed
        sender.send(Vec::from(flag_match.as_bytes())).unwrap();
    }

    // print!(".");
    // Sleep the remaining duration
    sleep(Duration::from_secs(config.interval as _) - (Instant::now() - start_time));
    Ok(())
}
